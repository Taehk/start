# day02

-Review--------------------------------------------------------------------------
자바를 이용해서 뭔가를 만들고 싶다면
  컴파일러가 필요하고
  연계편집을 위한 도구가 필요하다.
    ㄴ 이것을 자바가상머신(JVM)이라고 부른다.
  이 두 가지를 제공하는 도구를 다운 받아서 사용해야한다.
    ==> 그 도구 + @로 필요한 각종 패키지를 묶어서 제공된 것이 JDK이다.

남들이 만든 소스 구경하기
	1. System등에 마우스를 두고 Ctrl을 누름
	2. Attach Source - external에서 JDK파일의 Src.zip을 선택해서 확인
	3. 그 뒤엔 궁금한 코드 ctrl을 통해 소스 구경해보기.
	
===================================================================================

자바 만든 프로그램을 실행하는 원리
	1. 자바 언어의 문법에 맞게 자연어로 프로그램을 만든다.
								ㄴ 사람이 인식할 수 있는 언어 (<->기계어)
	     이 프로그램은 저장이 되어야 한다.
	     	1) 저장할 파일의 이름은 클래스명과 반드시 대소문자까지 동일해야 한다.
	     	2) 확장자는 반드시 .java로 만들어야 한다
	     			-> ex) Public class Test {} = Test.java

	 2. 만들어진 소스파일은 컴파일을 해야 한다.
	 	 그래야 컴퓨터가 이해할 수 있는 기계어가 탄생하기 때문이다.
	 	 
	 	 컴파일 하는 방법(형식)
	 	 	cmd에 경로	javac 파일명.java
	 	 		이때 옵션이 붙여질 수 있다.
	 	 
	 	 컴파일 단계를 거치면 확장자가 .class인 파일이 생성한다.
	 	 이 파일은 "바이트 코드"라고 한다.
	 	 		* 참고 - cmd 창에서는 현재 폴더에 있는 도구만 활용하는 것이 원칙이다.
	 	 				 다른 폴더에 있는 도구를 사용하기 위해서는 연결을 시켜줘야한다.
	 	 				 	ㄴ (해당 도구의 위치를 시스템이 인식하도록 경로를 환경변수 "Path"에 저장)
	 
	 3. 만들어진 class 파일은 배포가 된다.
	 		-> 다른 사람에게 실행하도록 줄 수 있다.
	 			실행 방법 = java 클래스이름


함수나 클래스 어떻게 쓰는지 알고 싶을 때 : doc- docs - api - index.html 들어가기	 			
---------------------------------------------------------------------------------------

  용어설명)
		
		패키지 : 비슷한 능력을 가진 프로그램(클래스)가 합쳐진 폴더
			ㄴ 기존에 있던 클래스명과 중복이라도 상관없이 사용하기 위해 패키지라는 폴더 개념이 나타남.
		
  		API 		= 운영체제와 프로그램 사이에 원활한 작동을 위해서 양쪽을 연결해주는 도구 (JDK 설치시 API도 함께 설치)
  		
  		라이브러리 	= API가 사용하는 도구에 필요한 정보를 기억한 프로그램의 일종
	  					ㄴ 특정 명령을 수행하기 위해 필요한 절차를 기록해놓은 문서
	  		=> API 안에는 라이브러리가 반드시 포함되어야함.
		
		주석 : 소스코드의 실행에는 영향을 끼치지 않고 주로 설명을 하는데 사용하는 문자열 (컴파일 X)
				단일행 = //
				다중행 = /* */
				배포문서에 포함되는 주석 - 설명 및 배포자, 배포날짜 등 입력
					 = /** 
					 	* 이 클래스는 주석의 형식을 보여주기 위한 클래스
					 	*	@author 김태현
					 	*	@since 2022.02.23
					 	*	@version v.1.0
					 	*/ 
					 	
		멤버 : 클래스에 포함된 변수와 함수
		필드 : 멤버로 만들어진 변수
		static멤버 : 멤버 중 속성이 static인 멤버
				static 영역의 멤버 한번만 올려짐 <-> new 시킨 애들은 그때마다 heap의 영역에 올려짐
				한번 올려진 static 영역의 멤버는 그대로 공유가 됨.
			ex) public static void main(String[] args){}
				ㄴ특징
					1) static영역에 실행되는 순간 미리 올려지는 멤버들.	(new시킨 애들은 heap의 영역에 올려짐)
					2) 해당 멤버가 소속된 클래스를 new 시켜서 메모리에 올려놓지 않아도
					   그 멤버는 사용 가능하게 함.
					3) static 영역에 올려지는 멤버는 같은 이름으로 여러개 올려질 수 없다.
						==> 변수의 경우 하나를 공유해서 사용하게 되는 결과가 생긴다.
					4) static 함수에서는 static멤버만(메모리에 기억되어 있는 멤버만) 사용할 수 있다.

		★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

  자바의 8개 메모리 영역 중 알아야할 4가지 영역
  
 		1. 스택(Stack)		: 변수들의 정보가 기억되는 공간 = 변수 이름만 기억하고 있으면 언제든 기억된 주소의 데이터 사용 가능
 			ㄴ 특징
 					1) 메모리에 별칭을 붙여서 사용할 수 있는 영역이다.
 					2) 별칭은 개발자가 붙이는 것이므로 개발자가 가장 손쉽게 사용할 수 있는 영역이다.
 					3) 8개의 영역 중에서 리터럴 풀 다음으로 가장 작은 영역을 운영체제에게서 배정 받는다.
 						ㄴ 그래서 많은 양의 데이터를 보관하면 문제가 되므로 리터럴 풀의 데이터가 가지는 주소만 저장함.
 				Stack영역에 메모리 할당 받는 법
 					= JVM에게 할당받은 메모리 크기와 그 안에 저장할 데이터 형태를 알려주어야함.
 						ㄴ 기본형 변수 선언
 		
 		2. 힙(Heap)		: 객체들의 정보가 기억되는 공간
 
		3.리터럴 풀(Literal Pool)	: 데이터 자체들이 모여있는 공간
 
		4. 스태틱(Static)	: 
 
 			
	상수와 변수
		1. 상수(Literal) : 개발자가 프로그램에게 알려주는 (정보)데이터
					* 상수명은 대문자로 한다.
					* 한 번 정하면 수정 불가능
					* 선언과 동시에 초기화가 이루어져야한다.
						ㄴ final 데이터타입 상수명 = 데이터;
											 ㄴ대문자
			ex) System.out.println("Hello");의 경우 : "Hello"는 상수. = literal pool에 일단 저장하고 사용되도록 되어있다.
						ㄴ 이때 일어나는 과정
								1) 리터럴 풀에 "Hello"라는 데이터 자체를 기억
										ㄴ 메모리 영역 = 기억되는 데이터는 주소를 가지게 된다.
												> 프로그램이 이 데이터를 사용하기 위한 주소로 접근하기 위해
												  주소를 저장시킨 것이 변수
								2) 리터럴 풀에 기억된 데이터를 꺼내서 출력하게 된다.
						
						자료형(종류)
							
							1) 정수형 : 소수점이 없는 일반적인 숫자
								* 변수 기본 저장형 = int
									10진수, 8진수, 16진수
									- byte(1바이트), short(2바이트), int(4바이트), long(8바이트)
							
							2) 실수형 : 소수점이 존재하는 숫자
								* 변수 기본 저장형 = double
														ㄴ height = 179. or double height = 179으로 선언하면 자동으로 실수형
									3.14, 3.0e5(지수 방식 3.0 * 10^5)
									- float(4바이트), double(8바이트)
							
							3) 논리형 : 참과 거짓을 의미하는 데이터
									true, false (자바에서는 0, 1로 논리형을 표현할 수 없음)
									- boolean(1바이트)
									
							4) 문자형 : '' 오직 한 글자로만 구성된 문자
										-> 입력한 문자를 유니코드 방식으로 변환해서 기억 (대소 판별 가능)
										'a' - 97(ascii코드)
										'/u0000' - 실제 유니코드 값으로 문자 기억가능 (0000을 원하는 문자 유니코드 값에 대응)
									- char(2바이트)
									
							5) 문자열(클래스타입) : "" 한 글자 이상으로 구성된 문자를 의미.
										-> 기본 데이터 타입(기본 상수)는 아니다. 너무 빈번하게 사용하여 포함시켰음.
									- string
		
		
		2. 변수 : 리터럴 풀의 데이터를 개발자가 "필요한 순간에 다시 재사용할 수 있도록" 저장된 주소를 기억하는 역할.
				  	* stack 메모리에 데이터를 저장해놓은 주소가 저장된다.
				  		ㄴ stack이 리터럴 풀 데이터 기억하는 법
				  			1. Stack에 필요한 메모리 할당받음.
				  				변수 선언
				  					* 데이터의 형태 + 데이터의 크기 + 필요한 메모리의 크기를 지정한다는 뜻.
					  					데이터 타입 변수이름;	ex) int abc;
					  						ㄴ 기억할 데이터의 형태 + 필요한 메모리의 크기
				  			2. 대입(기억) 연산자를 이용하여 필요한 데이터 기억.
				  					변수이름 = 데이터; 		ex) no = 10;
				
				데이터 타입에 의한 변수의 분류
					1) 기본형 변수 : 자바에서 제공해주는 기본 데이터 타입의 데이터를 기억하는 변수
								* 변수선언 + 초기화
				  					ㄴ 데이터 타입 변수이름 = 데이터;
					2) 참조형 변수 : 기본형 데이터 이외의 모든 데이터를 기억하는 변수 (클래스를 기억하는 변수 = 객체주소 저장)
									   클래스 이름 변수이름 = new 클래스이름()
		
		*  사용하고 있지 않은 변수는 변수 아래에 노란색 물결 밑줄이 있음.
				
		** 문자열 변수 만드는 방법
			1) 데이터 직접 입력해서 만드는 방법
				String name1 = "홍길동";
						ㄴ 스택	 ㄴ 리터럴 풀
			2) 클래스를 new 시켜서 만드는 방법
				String name2 = new String("홍길동");		
					ㄴ 스택 <new때문에>	ㄴ 리터럴 풀
			 힙의 주소 저장 <- 힙에 리터럴 풀 주소 저장					
					
	
	형변환 : 값의 자료형을 원하는 자료형으로 변환하는 작업
		- 리터럴 형변환
				입력할 데이터 뒤에 자료형을 붙임
					ex) float pi;
						pi = 3.14f;
						
				개발자가 입력하는 정수형 데이터는 특별한 조작없이 모든 데이터형이 기억될 수 있다.
				= 정수의 경우는 리터럴 형변환을 크게 신경쓰지 않아도 된다.
					ex) int a = 100;
						byte ab = 100;
						short c = 100;
						long d = 100;
		
		* 이미 리터럴 풀에 타입이 정해져 있는 경우
			- 자동 형변환				
				지정하지 않아도 자동적으로 형태를 바꿔서 사용되는 경우
					* float > long = 실수는 항상 정수보다 큼
						float num1 = 10;	<- 가능
						float num2 = 10.;  	<- 불가능
				* 타입이 다른 두 데이터의 연산의 결과는 항상 큰 타입쪽을 따른다.

			- 강제 형변환
				float num2 = 10.를 돌아가게 하려면?
					ㄴ float num2 = (float)10.; 가능 10.은 리터럴 풀에서 double형으로 저장
				* char + int시에 int형으로 자동 형변환됨.
					ㄴ 그 뒤에 강제 형변환으로 int만큼 뒤의 문자 생성
						ex) char ch1 = 'a'; int num = ch1 + 5; char ch1 = (char)num;
						
--------------------------------------------------------------------------------------------

속성 : Static = static 멤버는 static 영역의 클래스가 실행되는 순간 먼저 올려진다.

new = 클래스를 heap 메모리로 올리는 명령어	  ex) Test01 t1 = new Test01();  t1.abc(); => Test01 클래스에 있는 매서드 abc를 실행한다.


---------------------------------------------------------------------------------------------

* 함수는 함수 자신이 스스로 실행되는 경우는 없다.
* 함수는 반드시 누군가 호출해야 실행이 된다.
* 클래스가 실행되기 위해서는 JVM에 의해 실행되는 함수가 있어야 한다.
	ㄴ JAM이 사용하는 함수 : public static void main(String[] args) <- 이 함수만 호출을 하게 된다.
		=> 어떤 프로그램이 시작하기 위해 제일 처음 실행해야하는 함수는 진입점 함수(main함수)이다. 
	EX) public class 클래스명 {
		System.out.println("test"); <- 이 부분(클래스 블럭={} 바로 아래)에서 일반 실행 명령문은 함수없이 실행이 불가능하다.
										변수나 함수 등만 사용 가능	
		}
		==> 클래스는 변수와 함수로 구성된다.
		
			★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
		
				1. 클래스 안에는 필요한 함수나 필요한 변수를 포함할 수 있다.
					ㄴ 이때 포함되는 함수, 변수를 "멤버"라고 부른다.
					ㄴ 그 멤버로 만들어진 변수를 "Field"라고 부른다.
					ㄴ 멤버 중 속성이 static인 멤버는 static멤버라고 부른다.
				2. 클래스 안에 일반 명령은 절대로 올 수 없다.
					
					==> public class Test{
							int num;
							float area;			// 변수도 포함할 수 있다.
							
							public void xyz(){
							}
							public void abc(){	
							}					// 함수도 포함할 수 있다.
							
							public static void main(String[] args){
								실행내용		// 실행할 필요가 있을 경우에만 해당 함수 사용
							}
						}
						
						
---------------------------------------------------------------------------------------------

자바 프로그램의 토큰 구분

	=> 컴파일러는 토큰 단위로 번역을 시도한다.
		따라서 개발자는 컴파일러가 번역하는 토큰을 구분해주어야 한다.
		이것이 ";"라는 기호를 이용해서 구분하게 된다.
				ㄴ ; 대신 } 가 역할을 대신할 수 있다.
						ex) if(조건문){
								실행문.. <- ; 사용X
							} <-- 얘가 토큰 역할
				
		우리가 습관적으로 int no = 10; 이라고 했던 의미는 "토큰을 구분하기 위한 기호"였다.
		
		* 토큰은 "하나의 명령이 종료되었다."는 것을 뜻한다.
			ㄴ 만약 개발자가 토큰 구분을 하지 않으면 오류가 발생할 수 있다.
			ex) int no1 = 10
				int no2 = 20; -> 두 줄을 하나의 명령으로 인식 => 명령 형식이 존재하지 않음 => 오류
				
				