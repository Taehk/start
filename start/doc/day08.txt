day08

		배열 복사
			1) 얕은 복사
				ㄴ	주소만 복사
				* 데이터는 공유하기 때문에
					한곳에서 수정하면 다른 곳에서도 수정된 내용 사용	
				ex) int[] a = new int[5];
					...
					int[] b;
						이 변수는 배열의 주소를 기억할 변수를 만들어준 결과
						b 안에는 데이터를 기억할 수 없고
						오직 같은 Heap타입의 int[]의 주소만 기억할 수 있다.
					b = a;  <-- 얕은 복사				
				
				*지역 변수는 그 지역에서만 사용할 수 있으므로
				 다른 지역에서 데이터를 사용할 목적으로 많이 사용되는 방법
					(Heap은 프로그램이 종료되기 전까지 + 메모리가 모자라기 전까지 계속 메모리에 남아있기 때문)
				
			2) 깊은 복사
				ㄴ 데이터를 복사
				* 데이터가 복사되었다는 것은
				  Heap영역에 다른 인스턴스(new명령으로 생겨난 결과물)가 만들어졌다는 의미이므로
				  변수가 기억하는 주소가 달라지게 되므로
				  ***
				  복사된 데이터는 독립적으로 사용된다.			  
				ex) - System.arraycopy(#1, #2, #3, #4, #5);
						#1 - 원본배열의 주소
						#2 - 원본배열의 복사를 시작할 위치
						#3 - 복사받을 배열의 주소
						#4 - 복사받을 배열의 시작위치 값
						#5 - 복사받을 배열의 데이터의 갯수
						
		---------------------------------------------------------------------------
		
		배열의 단점
		
			1. 한 번 배열의 크기를 정하면 다시 조절이 불가능하다.
				ex) int[] no1 = new int[10];
					... // 작업 중 10개 추가해야하는 경우
					int[] no2 = new int[20];
					
					System.arraycopy(no1, 0, no2, 0, 10); // 데이터 복사
					no2[10] = ???;	// 추가 데이터 입력
					no2[11] = ???;
			
			2. 같은 형태의 데이터 타입만 관리할 수 있다.
				-> 주소는 Heap타입에 의해서 결정되고
					Heap type이 다르면 사용할 수 없다.
					
		----------------------------------------------------------------------------
		
		String배열
			String 역시 참조형 타입이다.
			String str = "Hong";
				ㄴ 이곳에는 데이터 자체의 주소가 기억되고
			String str = new String("Hong");
				ㄴ 이곳에는 Heap에 만들어진 인스턴스의 주소를 기억하고
					인스턴스가 데이터의 주소를 기억한다.
			
			*String배열 만들기
				String[] str; // 배열변수 선언, 데이터를 사용할 준비
				str = new String[5];
					-> 데이터 초기화가 되어있지 않은 상태
						아직 각 인덱스가 비어있는 상태(데이터가 결정되어 있지 않은 상태)
						
				str[0] = "Hong";
				str[1] = "Gil";
					-> 위처럼 데이터 공간까지 만들어줘야한다.
				
				String배열도 초기화 가능하다.
				String[] names = {"man1", "man2", "man3", "man4"};
				
			
			String 클래스에서 자주 사용되는 함수
				
				1. charAt(위치값)
				
				2. length()
				
				3. substring() -> 일부만 꺼내주는 함수
						substring(시작위치); -> 시작부터 마지막까지 모두 추출
						substring(시작위치, 종료위치);	-> 시작부터 종료위치까지 추출
				
				4. equlas() -> 문자열 데이터 자체가 같은지 비교해서 논리값으로 반환해주는 함수
				
	----------------------------------------------------------------------------------
			
			문자열도 필요에 따라서 char[] 형태로 변환해서 사용할 수도 있다.
				ex) toCharArray();
					String name = "Jenny";
					char[] ch = name.toCharArray();
						ch[0] -> J
						ch[1] -> e
						
						
	----------------------------------------------------------------------------------
	
		2차원 배열
			-> 1차원 배열을 관리하는 배열
				-> 배열 안에 다시 배열이 들어있는 형태
					* 정확히는 배열 안에 1차원 배열의 주소가 기억된다.
						ㄴ 2차원 배열 = 배열들을 관리할 배열
					
			만드는 법
				1. 배열 주소를 기억할 변수를 만든다.
					-> Heap 영역에 있는 데이터는 주소를 알아야 사용하기 때문이다.
					ex) 데이터타입[][] 변수이름;
						[]가 1개면 1차원, 2개면 2차원...
						int[][] num; <- 배열들을 관리할 배열 
						num = new int[5]; <- 안됨, Heap타입이 다름.
				
				2. 1차원 배열을 몇개를 관리할 지를 결정하고
					1차원 배열의 주소를 기억할 메모리를 만든다.
					ex) new 데이터타입[갯수][];
							-> 갯수는 1차원 배열의 갯수를 지정한다.
						num = new int[5][]; <- 5개의 배열을 관리할 방만 만들어둠.
				
				3. 실제 정수를 관리하는 1차원 배열의 길이를 결정하고
					1차원 배열의 주소를 기억할 메모리를 만든다.
					ex) new 데이터타입[갯수];
						num[0] = new int[3];
						
			* 2차원 배열도 사각형 형태의 배열을 만들 수 있다.
				ex) 데이터타입[][] 변수 = new 데이터타입[행수][열수];
					int[][] num = new int[5][3];
						-> 정수 3개를 관리하는
							배열 5개를 관리하는 배열
					ㄴ 별도의 메모리 공간을 차지하는 배열이 만들어지고
							그 배열을 관리하는 배열이 따로 만들어진다.
								=> 2차원배열 한칸한칸에 각 배열의 주소가 들어감
							
			* 2차원 배열도 초기화가 가능하다.
				ex) 1차원 배열의 경우 : int[] num = {데이터1, 데이터2, ...};
					2차원 배열의 경우 : int[][] num = {{데이터1,데이터2, ..},{데이터1,데이터2, ..},{데이터1..}}; 
			
				2차원배열 나열하기
					for(int i = 0; i < num.length; i++){
						for(int n : num[i]){	// 2차원배열에 속한 배열의 값 꺼내기
							프린트~;
						}
					}