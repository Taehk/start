# day15
		
		
		Random 클래스 
			-> 난수를 발생하는 클래스이다.
				우리가 알고 있는 Math.random()보다는
				좀 더 다양한 형태의 난수를 발생할 수 있는 장점이 있다.
				
				참고)
					Seed
						-> 컴퓨터에 난수 발생은 그 순간 실제로 난수를 만들어주는 것이 아니고
							이미 컴퓨터 내부에는 난수 테이블이 존재하고 있다.
							그리고 이 난수 테이블에서 순서대로 꺼내고 주는 역할을 한다.
							seed란 난수 테이블에서 난수를 꺼내는 위치를 말하는 용어
							
			-------------------------------------------------------------------------------
			
		BigDecimal
			-> 정수를 표현할 수 없는 숫자를 사용하기 위한 클래스
				주로 데이터베이스와 연동할 때 사용
					- 데이터베이스의 숫자 타입은
						오라클의 경우 NUMBER(숫자)는 최대 32자리까지 사용할 수 있다.
					  이런 형태의 데이터는 자바에서 처리할 수 없으므로
					  이런 유형의 데이터를 처리하기 위해 만들어진 클래스이다.
					ex) BigDecimal big = new BigDecimal("1231414542534523431233424214213");
					
		
			-------------------------------------------------------------------------------
			
		정규식(정규표현식) 검사
			-> 주어진 문자열이 특정한 규칙에 맞도록 만들어져 있는지를 확인하는 기능
				
				ex) 주민번호 6-7자리로 구성되었는지
					아이디가 순수하게 숫자/문자로 구성되어 있는지
					
				사용하는 클래스
					java.util.regex.Pattern
						-> 정규식 검사에 사용할 정규식 문법을 지정할 클래스
					java.util.regex.Macher
						-> 정규식 검사를 실제로 실행할 클래스
						
					참고) 정규표현식 문법
							1. c[a-z]*
								-> 문자를 기록하면 반드시 그 위치에 기록한 문자가 와야한다.
									[] 안에 기록하면 그 중 하나가 와야한다.
									*은 바로 앞에서 지정한 글자가 0개 이상 올 수 있다.
									-> c로 시작하고 그 후엔 알파벳 소문자가 0개 이상 오면 된다.
							
							2. c[a-z]
								-> c로 시작하고 그 다음 글자는 알파벳 소문자가 한 글자 와야한다.
								
							3. c[a-zA-Z]
								-> c로 시작하고 그 다음 글자는 알파벳이 한 글자 오면 된다.
							
							4. c[a-zA-Z0-9]
								-> c로 시작하고 그 다음 글자는 알파벳 / 숫자가 한 글자 와야한다.
								
							5. .*
								-> .은 모든 문자를 의미, 어떤 글자라도 0개 이상 오면 된다.
							
							6. C.
								-> 첫 글자는 C로 시작하고 다음 문자는 어떤 문자라도 한 글자 와야한다.
							
							7. C.*
								-> 첫 글자는 C로 시작하고 다음 문자는 어떤 문자라도 0개 이상 와야한다.
								
							8. c\.
								-> \.은 반드시 그 위치에 .이 와야한다.
								
							9. c\d
								-> \d는 숫자를 의미
								   첫 글자는 c로 시작하고 그 다음 문자는 숫자가 와야한다.
								   c[0-9]와 동일한 의미
								  
							10. c.*t
								-> 첫 글자는 c로 시작하고 마지막 글자는 t가 와야한다.
									중간에 어떤 문자라도 0개 이상 올 수 있다.
							
							11. [b|c].*
								-> b / c로 시작하고 그 이후엔 어떤 문자라도 0개 이상 올 수 있다.
									== [bc] == [b-c]
							
							12. [^b|c]
								-> ^ = NOT = b 또는 c가 아닌 문자 1개
								
							13. .*a.*
								-> a 문자가 포함된 모든 문자열
								
							14. .*a.+
								-> * : 0글자 이상
								   + : 1글자 이상
								 
							15. [b|c].{2}
								-> b또는 c로 시작하고 어떤 문자라도 그 이후에 2글자가 와야함
								-> {n} : n = 글자 수를 의미
								   {n, } : n개 이상
								   {n1, n2} : n1개 이상 n2개 이하
								   
							16. .{2,3}
								-> 어떤 문자라도 2글자 이상 3글자 이하가 와야한다.
								
						ex) 휴대폰 번호식
							01[0-9]-[0-9]{4}-[0-9]{4}
							
							전화번호식
							0[0-9]{2,3}-[0-9]{3,4}-[0-9]{4}
							
							
		**********************************************************************************
		**********************************************************************************
		**********************************************************************************
		
		콜렉션(Collection)
			-> 많은 양의 데이터를 손쉽게 보관할 수 있는 클래스들의 집합
			
				배열을 이용해도 많은 양의 데이터를 보관할 수 있지만
					1. 크기 변경이 불가능하다
						-> 한번 데이터의 양을 결정하면 그 양보다 많은 데이터는 보관할 수 없다.
					2. 데이터 입출력에 많은 제약을 갖는다
						-> 반드시 위치를 알아야 데이터 입출력이 가능하다.
						
				종류)
					1. List 계열
						특징
							1) 입력 순서를 보장한다(처리속도가 느리다)
							2) 중복데이터도 다시 저장할 수 있다.
					
					
					2. Set계열
						특징
							1) 입력 순서를 보장하지 못한다.
								(나름의 규칙에 의해서 데이터를 정렬해서 보관한다.)
							2) 중복 데이터를 허용하지 않는다.
								(중복된 데이터가 입력이 되면 먼저 입력된 데이터를 지우고 다시 저장한다.)
									= 같은 데이터는 한번만 저장한다.
									
					3. Map계열
						특징
							1) 데이터를 그 데이터를 구분하는 키값과 한쌍을 만들어서 저장하낟.
							2) 입력순서는 보장하지 못한다.
							3) 같은 키 값으로 데이터가 입력되면
									먼저 입력한 데이터를 삭제한다.
										-> 데이터는 중복되어도 상관없지만
											키 값은 중복해서 사용하면 안된다.
					
					참고)
						List계열과 Set계열은 같은 상위 클래스를 가지고 있다.
							ㄴ List와 set은 다형성 처리가 가능하다(서로 변환 가능)
						Map 계열은 상위 클래스가 다르다.
							ㄴ 독립적으로 변환이 불가능하다.
							
			----------------------------------------------------------------------------------------
			
			List계열
				
				1. Vector
					-> 내부적으로는 배열형태를 만들어서 데이터를 보관하는 컬렉션의 일종이다.
					
					장점
						입력속도와 검색속도가 빠르다
					단점
						중간에 데이터를 삽입하거나, 데이터를 삭제하는 속도는 느리다.
					결론
						데이터의 변화가 거의 없는 프로그램에서 많이 사용된다.
						
					생성방법
						
						1) Vector()
							-> 배열의 크기를 10으로 정한 상태로 벡터를 만들어준다
								이 때 데이터가 많으면 크기는 변경된다. ( 따로 정의를 하지 않으면 *2만큼 늘어난다).
						
						2) Vector(Collection c)
							-> 다른 컬렉션의 데이터를 복사해서 벡터를 만들어 준다.
							
						3) Vector(int initialCapacity)
							-> 사용자가 직접 배열의 크기를 정하면서 벡터를 만든다.
						
						4) Vector(int initialCapacity, int capacityIncrement)
							-> 3)번 + 데이터양이 증가할 때 추가할 배열의 크기를 정한다.
							
							
						참고) 컬렉션은 데이터의 양에 관계없이 항상 데이터를 입력받을 수 있다.
								이 때 데이터를 입력받을 공간을 확보해야하는데
								규칙은
									현재공간 * 2
								가 된다.
					
					주요함수
						1. 데이터 입력 함수
							add(Object obj)
							add(int index, Object element)
							addAll(Collection c)
							addAll(int index, Collection c)
							addElement(Object obj)
							insertElementAt(Object obj, int index)
								다 같은데 매개변수 등이 차이 있음.
								
						2. 데이터 수정 함수
							set(int index, Object element)
							setElementAt(Object obj, int index)
							
						3. 데이터 꺼내는 함수
							get(int index)
							elementAt(int index)
							firstElement()
							lastElement()
							elements()
							
						참고) E,V,K라고 표한 것은 Object를 의미하는 제너릭 용어이다.
						
		-----------------------------------------------------------------------------------------------------
		
		2. ArrayList
			-> Vector의 신 버전으로
				역시 배열 형태로 데이터를 관리하기 떄문에
				Vector의 특징을 그대로 가지게 된다.
				하지만 thread에서 동기화 처리를 자동으로 해주기 때문에 더 선호된다.
				
				사용방법 역시 Vector와 동일하다
				
				참고)
					List계열의 주소(변수)를 출력하면
					마치 데이터가 나온 것처럼 보이지만
					이것은 toString()를 오버라이드 해놓아서 반환된 문자열을 출력만 해주는 것이다.
					따라서 절대로 데이터를 사용하는 개념은 아니다
					
		3. LinkedList
			-> 내부적으로 이중 연결 리스트 방식으로 데이터를 보관하는 방식의 컬렉션의 일종이다.
				
				장점) 데이터를 중간에 끼워넣은 작업, 삭제 작업은 속도가 빠르다.
				단점) 데이터를 누적시키는 작업은 속도가 느리다.
				
				주로 데이터의 변화가 심한 경우 많이 사용하는 컬렉션이다.
				
			참고 클래스)
				Iterator
					-> 컬렉션은 많은 클래스의 집합이고 그 형태도 다르다.
						하지만 이들은 서로 혼용될 수 있다.
						그런데 이 안에서 데이터를 꺼내는 방식이 약간씩 다르다.
						List에서 데이터를 꺼내는 방식과 Set에서 데이터를 꺼내는 방식이 다르다.
							(꺼내는 소스를 다르게 만들어야한다)
							
						그래서 데이터를 꺼내기 위해서만 사용하는 클래스를 따로 만들어 놓아야 한다.
						그 클래스가 Iterator 클래스이다.
						즉, List계열이던 Set계열이던 Iterator로 변환만 시키면 한가지 방식으로
						데이터를 꺼낼 수 있게 된다.
						
						특징) 어제 배운 StringTokenizer처럼 순차적으로만 꺼낼 수 있고
							  한 번 꺼낸 데이터는 꺼내는 순간 자동삭제가 된다.
							  
				참고)
					Collections 클래스
						-> Collection의 기능은 없고
						   Collection을 이용할 때 필요한 부가적인 기능들을 제공하는
						   유틸리티적인 클래스
						   		* 매개변수에서 List를 요구하면 List계열을 주면 되고
						   			Set을 요구하면 Set계열을 주면 된다.
						   			Collection을 달라고 하면 List, Set 중 하나를 주면 된다.
						   			Map을 요구하면 Map계열을 주면 된다.
						   
						   참고)
						   		일반적인 정렬은 오름차순으로 진행한다.
						   		만약 정렬방식을 변경하고자한다면
						   		sort(List list, Comparator c)을 사용해야 한다.
						   		
						   		
						   		
						   		
		=================================================================================================
		
			Set계열
				-> 입력한 순서 그대로 보관하고 있을 보장이 없다
						(자기 나름의 규칙을 가지고 내부적으로 정렬해서 보관한다.)
				-> 중복된 데이터는 한번만 저장한다
						(같은 데이터가 입력되면 먼저 입력한 데이터를 냅두고 새로온 데이터를 지운다.)
			
				1. HashSet
					-> HashCode를 이용해서 정렬해서 보관하는 방식의 컬렉션
						따라서 우리가 생각하는 정렬이 이루어지지 않는다.
					
					참고) Set계열의 컬렉션은 꺼내는 기능의 함수가 존재하지 않는다.
						-> 왜?
							개발자가 데이터가 저장된 장소를 모르기 때문에
							특정 위치를 지정하면서 데이터를 꺼낼 수 없다.
							따라서 Iterator로 변환해서 순서대로 꺼내서 사용하도록 하고 있다
							or List계열로 변환해서 꺼내도 된다.
							
				2. TreeSet
					-> 내부적으로 TreeSort라는 알고리즘을 이용해서 데이터를 보관하는 기능을 가진 컬렉션의 일종
							= 입력되는 데이터는 반드시 정렬 가능한 데이터이어야 한다.
						특징 : 우리가 생각하는 정렬 방식을 사용
						
						생성방법 : TreeSet(Comparator comparator)
									-> 정렬방식을 변경해서 TreeSet을 만든다.
								   TreeSet(Sorted<E> s)
								   	-> TreeSet을 이용해서 다시 TreeSet을 만든다
								   	
						참고함수 :
							subSet()
								-> 하나의 Set에 담긴 내용 중에서 특정 부분만 골라서 새로운 Set을 만드는 함수
							headSet(E toElement)
								-> 처음부터 지정한 부분까지 골라서 새로운 Set을 만듦
							tailSet(E fromElemtn)
								-> 지정한 부분부터 끝까지 골라서 새로운 Set을 만듦