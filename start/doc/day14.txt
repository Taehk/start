# day14
	
	Review
		오버라이드 규칙
			1. 함수의 원형은 유지한다.
			2. 접근지정자는 같거나 넓은 방향으로
			3. 예외처리는 같거나 좁은 방향
					ㄴ 예외를 전이하는 함수는 thorws하는 예외는 같거나 줄어들 수 있다.
						하지만 상위 클래스에서 던지지 않은 예외를 던지면 안된다.
							ex) void add(int a, int b) throws InvalidNumberException, NotANumberException{}
							
										이것을 오버라이드 해서
								void add(int a, int b) throws InvalidNumberException, NotANumberException{}
									ㄴ 예외를 똑같이 써서 가능								
								void add(int a, int b) throws InvalidNumberException{}
									ㄴ 줄어든 것 가능								
								void add(int a, int b) throws Exception{}
									ㄴ 예외의 범위가 넓어져서 불가능					
								void add(int a, int b) throws NumberException{}
									ㄴ 원형이 던지지 않은 예외도 불가능
									
	---------------------------------------------------------------------------------------------------------------
	
			java.util 패키지 소속의 유용한 클래스
			
			1.Objects
				-> 이 클래스는 100% static 함수로만 구성된 클래스
					클래스(객체)를 다룰 때 유용한 몇 가지 유틸리티적인 함수로 구성된 클래스
				
				ex) isNull(Object obj)
						-> 객체의 내용이 있는지를 확인하는 함수
							ㄴ null = 참조형 변수에 주소가 없는 상태를 말하는 것
									= 찾아갈 대상이 아직 없다라는 뜻
									= 사용할 준비가 되어 있지 않았다.


	
	---------------------------------------------------------------------------------------------------------------
	
	int a = 10;
	int b = 10;
	
	a == b;
	
	Abc a = new Abc();
	Efg e = new Efg();
	a == e;
		// 서로 타입이 다름
	
	---------------------
	
	class Nemo{
		int width, hegiht, area;
	}
	Nemo n1 = new Nemo(10, 20);
	Nemo n2 = new Nemo(20, 10);
	
	n1 == n2 -> X 주소를 비교할 것이고, 비교할 기준도 없다(width? height? area? 다른거?)
	
	----------------------------------------------------------------------------------------
	
	Object클래스
		-> 자바로 만든 최상위 클래스 역할을 하는 클래스
			특별히 하는 일은 없고 자바에서 상속 관계를 명확하게 하기 위한 역할을 주로 많이 한다.
			
			1. equals()
				-> Object클래스가 가지는 이 함수는 내용을 비교하는 기능이 아니고
					주소를 비교하는 기능의 함수이다.
					
				참고) 우리가 클래스를 사용하는 방법

						1. 객체를 만들어야 한다. -> Heap영역에 내용을 올려놔야 한다.
								클래스이름 변수 = new 클래스이름();
																
						2. 변수(주소)를 이용해서 내부의 멤버들을 사용한다.
					
				String클래스의 equals()가 내용을 비교하는 함수인 이유는
				Object클래스의 equals()함수를 오버라이드해서 내용을 비교하도록 바꾼 것이다.
					-> 우리가 만든 클래스도 내용 비교를 하도록 원한다면
						이 함수를 오버라이드해서 기능을 수정하면 될 것이다.
							

			2. toString()
				-> 자바는 주소를 내부적으로 사용하고 있다.
					하지만 주소를 개발자에게 노출하지는 않는다
						대신 주소(변수가 기억하는 것)을 출력하면
							"클래스이름@해쉬코드값"의 형태로 출력하게 된다.
											ㄴ 자바는 주소를 내부적으로 해쉬테이블을 이용해서 관리한다.
												해쉬 코드값은 그 주소를 관리하는 해쉬테이블의 코드값이 된다.
												
					문제는 이런 주소를 출력하려고 하면 내용이 출력되는 것이 아니고 해쉬코드 형태의 코드값이 출력된다는 것이다.
					이것은 이런 형태의 문자열을 만들어서 반환해주는 기능의 함수가 자동 호출되어서 출력되는 것이다.
					이때 자동 호출되는 함수가 toString(); 이다.

					만약 우리가 만든 클래스에서 주소(변수)를 출력할 때
					해쉬코드 값이 아닌 우리가 원하는 데이터로 출력이 되게 하기 위해서는 toString()함수를 오버라이드하여
					원하는 형태의 문자열로 반환해주면 된다.
					
			3. clone()
				-> 자기 자신을 깊은 복사 해주는 함수
						이 함수는 protected 함수이므로
						상속 받은 클래스나 같은 패키지에 있는 클래스에서만 사용할 수 있다.
			
			4. hashCode()
				-> 해쉬테이블에 주소를 관리하는 코드값을 알려주는 함수
				
		--------------------------------------------------------------------------------
		
		String 클래스
			-> 문제열을 관리하는 클래스
			
				****
				주의사항)
					String 클래스의 가장 큰 단점					
						-> String 클래스는 내용이 변경되면
				           변경된 내용을 다시 메모리에 저장하고 주소를 바꿔치기 한다.
				           		-> String 내용 변화가 심하면 메모리 소모가 증가하게 된다.
				          
				         * 변화가 심한 문자열은 String 클래스를 사용하면 불리하다.
				         	-> 이때 사용할 수 있는 클래스
				         			ㄴ StringBuffer
				         			   StringBuild	가 제공되고 있다.
				         			   
				         그래도 간단한 문자열 처리는 자주 사용하는 클래스이므로
				         클래스 중 유일하게 new 시키지 않고 사용할 수 있도록 준비해 놓은 클래스이다.
				         
				         	ex) String str = new String("홍길동");
				         		String name = "홍길동";
				         참고)
				         	String 클래스는 유일하게 함수를 사용하지 않고
				         	연산자(+)를 사용해서 결합연산을 처리할 수 있다.
				         	
				         결론)
				         	변화가 심한 문자열 데이터는 String타입으로 작업하기 보다는
				         	StringBuffer를 사용해서 작업하는 것이 유리하다.
				         
				         참고)
				         	String소속의 함수는 자신이 기억한 데이터 자체를 변경할 수 있는 함수는 존재하지 않는다.
				         	다만 연산된 결과를 반환해주는 형태의 함수들만 존재한다.
				         	
		----------------------------------------------------------------------------------------------
		
		StringBuffer
			-> String과 동일하게 문자열을 관리하는 클래스이다.
					
					****
					차이점)
						String은 내용의 변화가 일어나면 새로운 메모리의 공간을 확보해서 사용하는데
						StringBuffer의 경우는 String의 이런 단점을 보완하고자 만들어진 클래스이다.
						내용에 변화가 생기면 현재 메모리에 변화된 내용을 그대로 기억한다.
						
					사용법)
						1. 객체를 만든다.
							StringBuffer buff = new StringBuffer([문자열]);
							
						2. 만들어진 객체에 문자열을 결합한다.
							buff.append(문자열);
							
						3. 문자열 데이터가 필요한 순간에 문자열로 변환시킨다.
							String str = buff.toString();
							
		------------------------------------------------------------------------------------------------------
		
		StringTokenizer
			-> 문자열을 특정 구분자를 기준으로 자르는 작업을 할 때 사용하는 클래스
				
				주의) 분리된 결과물은 배열과 같은 형태로 버퍼메모리에 기억되고
					  이 때 기억된 내용을 접근해서 사용하게 되면 그 내용을 메모리에서 사라지게 된다.
					  
				사용방법)
					StringTokenizer token = new StringTokenizer(문자열, 구분문자);
					while(token.hasMoreElement()){
						// 하나씩 꺼내서 작업하면 된다
						
						Object o = token.nextElement();
						String str = token.nextToken();
					}
					
		----------------------------------------------------------------------------------------------------------
		
		Math 클래스
			-> 주로 수학적인 기능을 처리하는 함수로 구성된 클래스
				멤버들이 모두 static멤버이므로 굳이 new 시키지 않아도 사용할 수 있는 클래스이다.
				아예 new 시키지 못하도록 해놓은 클래스이다. 
				
		래퍼클래스(Wrapper class)
			-> 주소를 사용하는 (클래스타입의 데이터를 사용하는) 곳에서
			value Type(기본데이터타입)을 사용할 수 없는 문제가 생길 수 있다.
			이런 문제를 해결하기 위한 클래스를 래퍼클래스라고 한다.
			즉, 정수데이터 int 타입을 객체의 형태로 사용할 수 있도록 만든 클래스이다.
			
			참고) 자바는 Object 클래스를 중심으로 계층 구조화해서 클래스를 이용하도록 만든 객체지향 언어다.
				하지만 Value Type(기본데이터타입)은 객체가 아니다. -> 다형성 구현에 있어서 문제가 발생한다.
			
			ex) 
				void abc(Object o){
				}	-> 이 경우 이 함수는 모든 데이터를 처리할 수 있는 기능으로 만들었음에도 불구하고
						기본데이터타입의 데이터는 이 함수로 처리할 수 없는 문제가 발생한다.
			참고)
				Boxing		: 기본 데이터 타입을 참조형 타입으로 변환하는 것
				UnBoxing	: 참조형 타입의 데이터를 기본형 타입으로 전환하는 것
								Heap 영역에 있는 데이터를 다시 Stack으로 꺼내는 것
					
				* 레퍼클래스란 Boxing과 UnBoxing을 해주기 위한 클래스이다.
					자바 버젼 1.4이후로 Boxing과 UnBoxing이 자동으로 처리된다.
				ex) Integer no1 = 10;	// 자동 Boxing
					int num = no1;		// 자동 UnBoxing
					
			
			boolean	<->	Boolean
			char	<->	Char
			short	<->	Short
			int		<->	Int
			long	<->	Long
			float	<->	Float
			doulbe	<->	Double
			