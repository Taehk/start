# day03

	컴퓨터가 숫자를 기억하는 방법 => 이진법
		정수의 경우
			-> 2진수로 변환, 부호비트는 무조건 0.
				ex) 10 -> 1010(2)
					0001010 <- 기준은 1바이트, 부호비트는 왼쪽
		음수의 경우
			-> 9의 보수법을 이용해서 처리한다.
				1) 양수로 가정하고 2진수로 변환한다.
				2) 보수화 시킨다. (0->1, 1->0 => 비트를 뒤집는다.)
				3) 거기에 +1
				4) 부호비트에 강제로 1을 지정한다.

	-------------------------------------------------------------------------
	
	용어 설명)

		연산자 	: 데이터를 가공하기 위해서 사용되는 기호
					= 가공방식을 나타내는 기호
		피연산자 : 가공에 사용되는 데이터
			1 + 2 -> + = 연산자 / 1, 2 = 피연산자
			
			-> 연산자를 사용하면 가공된 결과가 나오는데
				이 결과는 항상 큰 형태로 나오는 것을 원칙으로 한다.
					int + double -> double	(데이터 타입의 자동 형변환)
					 ㄴ double로 자동 형변환
					기본데이터타입 + String -> String
								   ㄴ 이 때 +는 산술 연산자가 아닌 결합 연산자로 작동한다.
			
		* 대입 연산자를 제외한 연산자는 "왼쪽에서 오른쪽"으로 연산한다.
		    ㄴ int x = 10;				    ㄴ "3.14" + 3.14 + 10  => 해결법? "3.14" + (3.14 + 10)
		  	   ㄴ10을 저장하고 int x 저장	   -> "3.143.14" + 10
		  									   -> "3.143.14120"
											ㄴ 같은 연산자가 중복된 경우에 한함.
										
			
		* 프로그래밍에서는 절대로 3개 이상의 피연산자를 동시에 비교 연산하는 경우는 없다.
			ㄴ 1 < x < 10 <- 불가능
			   x > 1 and x < 10 <- 이렇게 해야함.

			   
			연산자 종류
			
				1. 사칙연산자
					기호 + - * / %
						참고) / % 따로 있는 이유? -> int 둘이 연산 시에 소수점 X
						* 사칙연산자는 피연산자가 반드시 2개 이상 필요하다.
						* 왼쪽부터 차례로 계산해서 결과값을 만들어나간다.
						* "+" 기호는 문자열 연산에서도 사용할 수 있다.

						
				2. 대입연산자
					기호 = += -= *= /= %=
						변수에 데이터를 기억하도록하는 연산자
						* 반드시 대입연산자 왼쪽에는 변수가 오른쪽에는 데이터가 위치해야 한다.
						* 자바는 모든 연산이 반드시 대입연산자가 있어야 기억할 수 있다. (변수가 기억하기 때문)
						* 변수 = 변수 + 데이터;
						  변수 += 데이터; 			-> 서로 같다.
					
				3. 증감 연산자
					기호 ++ --
						++변수 : 처리한 뒤에 +1 계산
						변수++ : +1 계산한 뒤에 처리
							ㄴ ex) int no1 = int no2 = 10;	// 귀찮아서 이렇게 표현했는데 이거 안됨
								   int no3 = no1++;	-> no1 = 11, no3 = 10
								   int no4 = ++no2; -> no2 = 11, no4 = 11
						* 모든 연산은 일반적으로 중앙처리장치에서 처리되는 것이 원칙이다.
						  but 증감연산자, 시프트연산자는 중앙처리장치를 거치지 않는다.
						  	  메모리 상에서 연산되서 처리된다. -> 성능이 좋다 = 빠르다.
						
				4. 부호반전연산자
					기호 -
						형식 -데이터;

				5. 비교연산자   
			   		기호 > < == != >= <=
			   			두 데이터의 대소 관계를 비교하는 연산자
						* 사용되는 데이터와 관계없이 항상 논리값(불리언 True/False)으로 나온다.
							ㄴ 제어 명령에서 질문이 필요할 때 사용 : if, for, while 등
						* 문자열을 비교할 경우에는 equals()를 사용해서 비교해야 데이터를 정확하게 비교하게 된다.
							ㄴ 그냥 대입 == new String은 데이터가 같아도 주소값이 서로 다르기 때문
						
			    6. 논리 연산자
			    	기호 &(AND)  |(OR)
			    		 &&(AND) ||(OR) <- 절삭연산 : 하나만 확인해도 값이 나오는 경우 뒤를 볼 필요 없으면 확인 안함.
			    		 					ㄴ && : 전자가 False면 이미 fasle / || : 전자가 True면 이미 True
			    		 						ㄴ 특정 부분의 계산식은 계산하지 않도록 한다.(= 읽지 않는다.)			    		 							
			    		 !(NOT)			    		 
			    		두 논리값 사이의 관계를 따지는 연산자
			    		-> 즉 논리값을 AND, OR, NOT 방식으로 관계를 알아보는 연산자
			    		* 데이터는 반드시 논리값이어야 한다.
			    		* 컴퓨터는 질문을 한 번에 한개씩만 받는다. -> 크면 큰거고, 작으면 작은 것
			    				=> 두 질문을 동시에 만족하는지 등을 묻기 위해 논리 연산자를 사용한다.

			    7. 비트 연산자
			    	기호 & |
			    		 ^(XOR) - 같으면 0, 다르면 1
			    		 ~      - 보수화 연산자(단항 연산자) 비트의 숫자를 반대로 바꾸는 연산자
			    		C언어에서 가지고 온 연산자
						ex) 20 & 36 -> 20 -> 00010100(2)
									   36 -> 00100100(2)
										      ㄴ00000100(2) -> 4

				8. 시프트연산자
					기호 >> << >>>
						ex) 20 >> 2; (오른쪽으로 2칸 밀기) = 20을 2^2로 나눠라
							-> 00010100(2) -> 00000101(2) -> 5
							* 부호비트는 그대로
							  num << n; num을 n^2만큼 곱해라
							  num >> n;	num을 n^2만큼 나눠라
							   부호비트까지 쉬프트
							  num >>> n; num을 n^2만큼 나눠라 
						* 이 연산은 boolean, float, double 형의 경우는 사용할 수 없다.
						* int형의 경우 4바이트이기 때문에
							-8의 경우 10000000 / 00000000 / 00000000 / 00000010(2)인데
								이를 1개 >>>로 옮긴다면 01000000 / 00000000 / 00000000 / 00000001(2)로 값이 엄청 커져버린다.
						* 증감연산자와 마찬가지로 CPU를 거치지 않은 연산을 함.
						* 아예 밀려버린 비트는 삭제
						
						
			    9. 3항연산자 (조건연산자)
			    	기호
			    		조건에 따라서 처리할 내용을 구분해서 처리하도록 하는 연산자.
			    			ㄴ 하나의 명령에 가까운 형식을 가진 연산자의 한 종류
			    			ㄴ if 명령을 단순화시킨 의미를 가진 명령
			    	형식
			    		(조건식) ? (조건식이 참일 때의 처리내용/반환값) :(조건식이 거짓일 때의 처리내용/반환)
			    		 	ㄴ 참 아니면 거짓이 나올 수 있는 구문만
			    		 * ?와 : 쓰는 것 잘 기억하기
			    	* 모든 연산자가 중첩 처리되듯이 3항 조건연산자도 중첩처리될 수 있다.
			    		ㄴ ex) (조건식1) ? ((조건식2) ? () : ()) : ((조건식3) ? () : ()));
			    				-> 조건식1이 참일때 조건식2, 거짓일때 조건식3으로 넘어가기
			    	
		--------------------------------------------------------------------------------------------
				import시 * 기호의 의미
						모든 것을 의미 -> 하위 클래스는 index에서 찾아보기
						
						
				System.out.println(데이터);에서는 오직 한 개의 데이터만 출력할 수 있다.
					ㄴ System.out.println("홍길동", "고길동", "둘리"); <-- 불가능
					
		---------------------------------------------------------------------------------------------
		
		코드 정리)
		
			사용자에게 입력받기
							
				import java.util.*;
				
				public static void main(String[] args){
					Scanner sc = new Scanner(System.in);
							ㄴ변수명 <-변수로 저장 ㄴ시스템에 사용자가 입력하는 데이터
					int num = sc.nextInt();
					String str = sc.nextLine();
					float fl = sc.nextFloat();
						등등 해당 자료형으로 입력받아서 처리 가능
					
					int convertNum = Integer.parseInt(str);	
						이건 입력받은 자료형을 다른 자료형으로 변환하는 코드									
			}