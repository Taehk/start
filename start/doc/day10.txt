day10
		************************************************************************
		Friend[] anne = new Friend[4]; 사용하면 null값으로 주소만 제공해둔 것이니까
		for(int i = 0; i < anne.length; i++) {
			anne[i] = new Friend();	-> 각 방에 데이터 채우기
		************************************************************************
		
		다중 드래그 - ctrl+f replace하는 법
		
		접근지정자
			-> 그 내용을 어디까지 사용할 수 있게 하는지 지정하는 예약된 용어
			
			우리가 클래스를 제작한다고 해서
			그 클래스(내용) 모든 사람에게 공개되는 것은 아니다
			클래스를 제작하는 사람이 사용범위를 지정할 수 있다
			
				ex) class는 누구까지 이 클래스를 사용하도록 할 것인가?
				    new 시킬 수 있도록 할 것인가?
				    함수는 어디까지 이 함수를 호출 할 수 있도록 할 것인가?
			
			1. public
				-> 모든 곳에서 사용할 수 있다
				
			2. protected
				-> 상속받은 하위 클래스 + 같은 패키지 소속의 클래스에서만 사용 가능
			
			3. 생략된 경우
				-> 같은 패키지 소속의 클래스들에서만 사용가능
			
			4. private
				-> 다른 클래스에서는 절대로 사용 불가능
				
			접근 지정자의 범위
				pirvate < 생략 < protected < public 
				
			참고) class는 지정할 수 있는 접근지정자는 public과 생략만 사용가능하다.
			
	---------------------------------------------------------------------------------		
			
		객체지향 언어의 특징
			1. 상속
			2. 다형성
			3. 은닉화 / 캡슐화
				ㄴ 프로그램에 있어서 가장 중요한 요소는 데이터이다.
				   즉, 변수가 프로그램에서 핵심적인 요소가 된다.
				   무결성(결함이 없는 성질) 데이터를 유지할 수 있는 것이 가장 중요한 개념이 된다.
				   
				은닉화란?
					이처럼 중요한 요소인 변수를 사용자가 함부로 변경하지 못하도록 방지하는 기법
								( = 결점 있는 데이터가 들어올 수 없도록)
						ex) 형식이 2002년 03월 08일인데 사용자가 입력을 02/03/08로 하는 경우 등
					1. 중요한 데이터가 기억될 변수의 접근지정자를 private로 지정한다.
						-> 그 변수는 다른 사용자가 사용할 수 없게 한다.
					2. 대신 변수의 데이터를 변경하거나 값을 꺼내올 수 있도록 방법(함수)을 만들어 놓는다.
					
*** this. = 현재 실행 중인 객체 자기 자신의 주소를 기억하는 변수. ****
		ㄴ 이 클래스의 객체가 여러개 만들어질 수 있는데
			그때마다 그 객체들의 주소를 각각 기억하고 있는 변수
	
	함수 내에서 변수를 찾는 규칙
		-> 기술된 위치에서 가장 가까운 변수를 찾게 된다.
	
		
		상속
			상속관계에 있는 경우
			상위 클래스 타입의 변수로 하위 클래스 타입의 인스턴스를 기억시킬 수 있다.
				변수의 경우는 변수쪽 데이터를 사용하게 되고
				함수의 경우는 인스턴스쪽 함수를 사용하게 된다
				
				1. import로 상속할 클래스 불러오기
				2. public class 상속받을 클래스명 extends 상속할 클래스명{}
					or class 만들때 super class로 상속할 클래스 선택하기
					
	================================================================================================
	
	생성자 [함수] (Constructor)
		-> 만들고자 하는 클래스의 목적에 따라 수행해야할 가장 기본적인 일을 처리하기 위해 만드는 것
		-> 클래스를 사용하기 위해서 new명령과 함께 호출해주어야 하는 함수
		
		즉, 클래스를 new한다는 것은 오브젝트를 만들어서 실행한다는 것이다.
		따라서 이때 실행한다는 개념은 결국 오브젝트를 만드는 순간에 뭔가를 실행한다는 개념이다.
		이 말은 물건을 만들 때 필요한 무언가를 한다는 조치를 한다는 개념이다.
		
		결론적으로 물건을 실제로 만들기 위한 함수..
		
		클래스는 한가지 목적을 달성하기 위해 만들어지는 프로그램의 기본 단위
		이 안에는 그 목적을 달성하기 위한 변수, 함수로 구성되어 있다.
		하지만 그 목적을 달성하기 위해서는 가장 기본적으로 뭔가 조치가 필요한 경우도 있다.
		
		ex) String -> 문자열을 관리하기 위한 목적으로 만들어진 클래스
					= 존재의미는 문자열을 기억하는 것
					
			FileOutStream -> 파일의 내용을 기록하기 위한 목적으로 만들어진 클래스
					= 파일을 사용할 수 있도록 열어놔야 한다.
			
			Socket -> 네트워크를 구성하기 위한 목적으로 만들어진 클래스
					= 상대방과 접속을 유지하고 있어야함
					
			* 프로그램은 프로그램답게 뭔가 조치하기 위해서는 함수(기능)가 필요하고
				위의 예시를 보면 각각의 클래스는 객체(오브젝트)로 만들어지는 순간
				그 클래스만의 최소한의 일은 할 필요가 있음
						-> 그 일을 하기 위해 만들어놓은 함수를 "생성자 함수(Constructor)"라고 부른다.
						
		* 만드는 법(규칙)
			1. 함수의 이름은 반드시 클래스 이름과 동일하게 작성해야 한다.(case sensetive)
			2. 반환값은 절대로 가지면 안된다. (이미 있는 기능을 세팅해주는 역할이기 때문)
			3. 매개변수는 가질 수 있다.
					ex) String str = new String("나는 문자열");
						String str2 = new String();
					ex) class Test {	
							public Test(){    <- 클래스 이름과 동일하게	+ 반환값 가질 수 없다(void도 있으면 안됨)
							}		// 매개변수가 없는 생성자를 기본 생성자라 이야기 한다.	
							public Test(int a){}
								
							public Test(String name){}
						}
						이 클래스를 객체로 만들 때...
							new Test();			-> 가능
							new Test(int a);	-> 가능
							
			* 클래스를 만들 때 생성자를 만들지 않으면
				매개변수가 없는 함수 블럭의 내용이 없는 기본생성자를 JVM이 만들어서 호출해준다.
					ㄴ 만약 생성자를 한 개라도 만들면 JVM이 기본생성자를 만들지 않는다.
						==> 되도록 기본생성자는 반드시 기술해주는 편이 좋다.
			
			* 매개변수가 있는 생성자를 호출하기 위해서는 new 시킬 때 매개변수가 필요한 데이터를 주면서 new 시켜라.
			
		* 이용 방법
			생성자 함수는 그 클래스를 어떻게 new 시킬지 알려주는 함수이다.
			즉, 생성자가 요구하는 매개변수가 무엇인지를 보면 그 클래스를 객체로 생성할 수 있는 방법이 나온다.
			
			따라서 클래스를 만들 때 다양한 방식으로 생성자를 정의해두는 것이 좋다.
			
					* 참고 :
						this() -> 생성자 함수는 원칙적으로 개발자가 직접 호출할 수 없다.
						-> 현재 생성자를 실행하는 도중에 다른 생성자를 강제로 호출하는 유일한 방법
							****규칙****
								1. 반드시 생성자 안에서만 사용할 수 있다.(다른 함수에선 호출 불가능)
								2. 반드시 생성자 내에서 첫문장 첫명령으로만 사용해야 한다.(생성자의 첫 라인에 가야함)
								
								프로그램은 한가지 목적을 가진 프로그램의 집합
									= 오버로딩된 생성자가 하는 역할은 거의 비슷
									= 코드의 내용도 거의 비슷
									= 생성자가 여러개 만들어지면 비슷한 코드가 중복된다.
									= 생성자끼리는 서로 필요하면 상대방을 이용할 수 있게 만든 방법.
									
		-------------------------------------------------------
		
			가변인자 = 함수가 가진 매개변수와 동일한 개수 형태 순서로 호출하는 것이 필요한데
						데이터 개수를 지정할 수 없는 경우에 사용하는 변수
					* 데이터 개수에 상관없이 모든 데이터를 다 받을 수 있다. *
					
				형식) 접근지정자 반환값타입 함수이름(변수타입...변수이름){}
						ex) public void printSum(int ... num){
							} -> 호출 할 경우 -> printSum(10); printSum(12, 31, 24); 가능
						* 주의 사항
							- 가변인자로 정의된 매개변수는 자동 배열변수가 된다.
								-> 입력된 데이터를 다룰 때는 배열처럼 사용해야 한다.
							- 가변인자 앞에 다른 매개변수가 와도 된다.
									public void asd(float a, int ... b){} -> 가능
							- 가변인자 뒤에 다른 매개변수가 와선 안된다.